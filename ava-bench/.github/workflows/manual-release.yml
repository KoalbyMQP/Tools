# .github/workflows/manual-release.yml
name: Manual Tool Release

on:
  workflow_dispatch:
    inputs:
      tool_name:
        description: 'Tool to release (ava-bench, perfmon-cli, monitoring)'
        required: true
        type: choice
        options:
        - ava-bench
        - perfmon-cli
        - monitoring
      force_version:
        description: 'Force specific version (optional)'
        required: false
        type: string

jobs:
  manual-release:
    runs-on: ubuntu-latest
    steps:
    - name: Checkout
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Setup Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.12'

    - name: Install uv
      uses: astral-sh/setup-uv@v3

    - name: Release Selected Tool
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        TOOL_NAME: ${{ github.event.inputs.tool_name }}
        FORCE_VERSION: ${{ github.event.inputs.force_version }}
      run: |
        python3 << 'EOF'
        import yaml
        import subprocess
        import os
        from datetime import datetime

        tool_name = os.environ['TOOL_NAME']
        force_version = os.environ.get('FORCE_VERSION', '').strip()
        
        # Load tools config
        with open('.github/tools.yml', 'r') as f:
            config = yaml.safe_load(f)

        if tool_name not in config['tools']:
            print(f"Tool {tool_name} not found in configuration")
            exit(1)

        tool_config = config['tools'][tool_name]
        tool_dir = tool_config['directory']
        
        print(f"Manually releasing {tool_name} from {tool_dir}")
        
        # Load tool-specific config
        ci_config_path = f"{tool_dir}/.ci.yml"
        if os.path.exists(ci_config_path):
            with open(ci_config_path, 'r') as f:
                ci_config = yaml.safe_load(f)
        else:
            ci_config = {}
        
        # Change to tool directory
        original_dir = os.getcwd()
        os.chdir(tool_dir)
        
        try:
            # Install dependencies
            if 'install_cmd' in ci_config:
                subprocess.run(ci_config['install_cmd'], shell=True, check=True)
            
            # Build package
            build_cmd = ci_config.get('build_cmd', 'uv build')
            subprocess.run(build_cmd, shell=True, check=True)
            
            # Generate version
            if force_version:
                version = force_version
            else:
                timestamp = datetime.now().strftime('%Y%m%d%H%M%S')
                version = f"0.1.{timestamp}"
            
            # Create tag
            tag_name = f"{tool_name}-v{version}"
            subprocess.run(['git', 'tag', tag_name], check=True)
            subprocess.run(['git', 'push', 'origin', tag_name], check=True)
            
            # Create GitHub release
            release_name = f"{tool_config.get('display_name', tool_name)} v{version}"
            
            subprocess.run([
                'gh', 'release', 'create', tag_name,
                '--title', release_name,
                '--notes', f"Manual release of {tool_name}",
                'dist/*' if os.path.exists('dist') else '--notes-file', '/dev/null'
            ], check=True)
            
            print(f"Successfully released {tool_name} as {tag_name}")
            
        finally:
            os.chdir(original_dir)
        EOF